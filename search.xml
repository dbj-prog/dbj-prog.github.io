<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>悲观锁与乐观锁</title>
    <url>/2020/05/29/CAS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="1-悲观锁与乐观锁"><a href="#1-悲观锁与乐观锁" class="headerlink" title="1.悲观锁与乐观锁"></a>1.悲观锁与乐观锁</h4><p>悲观锁和乐观锁是两种并发控制机制。在并发环境下如果想要正确访问共享数据就需要提供一种机制来防止数据冲突。这种机制就是对访问的数据进行加锁。</p>
<h5 id="悲观锁（悲观并发控制）"><a href="#悲观锁（悲观并发控制）" class="headerlink" title="悲观锁（悲观并发控制）"></a>悲观锁（悲观并发控制）</h5><p>就是以一种悲观的态度来防止一切数据的冲突，synchronized就是一种悲观锁，在访问数据前先把数据锁住，然后才开始对数据进行读写，在他释放锁之前任何人都不能操作这个数据。如果有多个线程都想访问这个数据，但是某一时刻只能有一个线程访问，那么其余的线程就必须处于等待状态，直到锁被释放。这种方式会增加开销降低性能。</p>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>是基于冲突检测的，它假设发生冲突的概率是很小的，在自己完成之前不会被其他线程干扰。所以在数据进行提交更新的时候才会正式对数据的冲突与否进行检测，如果冲突了就给用户返回错误信息，让用户决定如何做。</p>
<h4 id="2-CAS算法"><a href="#2-CAS算法" class="headerlink" title="2. CAS算法"></a>2. CAS算法</h4><p>CAS（Compare and Swap）算法将内存中数据的值和自己最后一次读取的值进行比较，如果相同则表明没有被其他线程干扰，那么他就给数据赋新值，并返回这个新值；如果和自己认为的值不同，则表明被其他线程干扰，那么它就会返回内存中的值并放弃本次操作，重新尝试或者什么都不做。</p>
<p>CAS算法中有三个重要的参数：</p>
<ul>
<li>V：数据的实际值</li>
<li>A：线程最后一次读取的值</li>
<li>B：覆盖V的新值</li>
</ul>
<p>执行流程：V和A相同吗，如果相同就将B的值赋值给V，如果不相同说明V被其他线程更改了，当前值无效，放弃本次操作，再次尝试或者放弃。</p>
<p>注意：CAS算法是原子操作，它的正确执行是操作系统层面进行保证的。</p>
]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Callable和Runnable</title>
    <url>/2020/05/31/Callable%E5%92%8CRunnable/</url>
    <content><![CDATA[<h4 id="1-Callable与Runnable"><a href="#1-Callable与Runnable" class="headerlink" title="1. Callable与Runnable"></a>1. Callable与Runnable</h4><p>Callable和Runnable都是创建线程的方式，并且都是只有一个方法的接口。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 可能抛出的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两者的不同之处在于Runnable中的run()不能有返回值并且不能抛出异常，而call()方法可以有返回值并且可以抛出运行中可能存在的异常。</p>
<h4 id="2-Future与FutureTask"><a href="#2-Future与FutureTask" class="headerlink" title="2. Future与FutureTask"></a>2. Future与FutureTask</h4><p>既然Callable的call方法可以返回值，那么我们该如何获取这个返回值呢？Java中提供了Future接口用于接收Callable对象产生的值。Future的get()方法就是用来获取线程返回的值。调用该方法线程会被阻塞直到计算完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//提交任务，并用Future接收返回的结果</span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(<span class="keyword">new</span> CallableTask());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取结果并打印</span></span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//关闭线程池</span></span><br><span class="line">            executor.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是使用线程池的方式创建线程并使用Future来接收计算结果。如果使用Thread来创建线程，那么该如何接收结果呢？这时候就需要使用FutureTask类,这个类实现了RunnableFuture接口，而RunnableFuture继承了Runnable和Future接口。FutureTask可将Callable转换成Future和Runnable。因此我们可以通过如下的步骤获取Callable对象的返回值：</p>
<ol>
<li>创建Callable对象</li>
<li>使用FutureTask封装Callable对象</li>
<li>将FutureTask对象传递给新创建的线程（因为FutureTask实现了Runnable接口）</li>
<li>通过FutureTask的get()方法获取返回值（因为FutureTask实现了Future接口）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行Callable方式，需要FutureTask实现类的支持， 用于接受运算结果，FutureTask是Future接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CallableDemo cd = <span class="keyword">new</span> CallableDemo();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(cd);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">int</span> sum = task.get();<span class="comment">//返回的是线程的结果，只有当线程执行完才会执行有值。</span></span><br><span class="line">        System.out.println(sum);<span class="comment">//只有当子线程执行完才会打印结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>Callable</tag>
        <tag>Runnable</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>默认</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的线程池</title>
    <url>/2020/05/31/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h4 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h4><p>池化技术对于我们并不陌生：数据库连接池、Http连接池都是常见的池化技术。同理，对于线程而言，创建一个新的线程是有一定代价的，因为涉及到与操作系统的交互，并且创建大量的线程会造成很大的开销大大降低性能甚至使虚拟机崩溃。如果程序中创建了大量的生命周期很短的线程，就应该使用线程池。一个线程池中包含许多准备运行的空闲线程。将Runnable对象交给线程池，就会有一个线程调用run方法。当run方法执行完成后这个线程并不会被销毁，而是继续放回到线程池为下一个请求服务。</p>
<h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>Executor类有许多静态工厂可以创建线程池，如下表</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>newCachedThreadPool</td>
<td>必要时创建新线程；空闲线程会被保留60秒</td>
</tr>
<tr>
<td>newFixedThreadPool</td>
<td>创建固定数目的线程，空闲线程会一直保留</td>
</tr>
<tr>
<td>newSingleThreadExecutor</td>
<td>创建只有一个线程的线程池，该线程顺序执行每一个提交的任务</td>
</tr>
<tr>
<td>newSheduledThreadPool</td>
<td>用于创建在指定时间之后执行任务或者周期性的执行任务的线程</td>
</tr>
<tr>
<td>newSingleThreadScheduledExecutor</td>
<td>用于预定执行而构建包含单个线程的线程池</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域</title>
    <url>/2020/06/13/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的区域。这些区域都有各自的用途，以及创建和销毁的时间。Java虚拟机所管理的内存将会包括如下几个运行时数据区域：</p>
<p>==图片==</p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>​        Java程序需要先编译成字节码文件后再解释执行，字节码解释器在解释执行的过程中需要不断读取字节码的内容，程序计数器就是当前线程所执行的字节码的行号指示器。解释器依次读取程序计数器所指示的字节码内容。</p>
<p>​        由于Java虚拟机的多线程是通过时间片轮转来实现的，那么当从一个线程切换到另外一个线程就需要知道这个线程上次执行到了哪里，以便从上次执行的地方继续执行，因此每一个线程都应该拥有一个程序计数器（程序计数器是线程私有的），各个线程之间计数器互不影响，独立存储。</p>
<p>​        如果线程正在执行的是Java方法那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器的值就是空（undefined）。程序计数器是一块较小的内存空间，并且是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>​       与程序计数器一样Java虚拟机栈也是线程私有的，他的生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量/操作数栈、动态链接、方法出口等信息。方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
<p>​       局部变量表存放了编译期可知的各种基本数据类型（Boolean, byte, char, short, int, float, long, double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和<code>returnAddress</code>类型（指向了一个字节码指令的地址）。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法所需要在栈帧中分配多大的局部变量空间时完全确定的，在运行期间不会改变局部变量表的大小。</p>
<p>​       在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机栈所允许的深度，那么就会抛出<code>StackOverflowError</code>；如果虚拟机栈可以动态扩展，并且扩展后仍不能申请到足够的内存空间那么就会抛出<code>OutOfMemoryError</code>.</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>​        本地方法栈和Java虚拟机栈的作用是类似的，只不过Java虚拟机栈是在执行Java方法时使用的，而本地方法栈时在执行native方法（非Java方法）时使用的虚拟机规范中并没有对本地方法栈中方法使用的语言、使用方式和数据结构进行强制规定，因此由具体的虚拟机自己实现。有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一与虚拟机栈相似该区域也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>.</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java中的堆时内存管理中最大的一块，它是一个被线程共享的区域。它的唯一目的就是存放对象的实例，几乎所有的对象实例都在这分配内存。但是随着<code>JIT</code>编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化。</p>
<p>Java堆时=是垃圾收集器管理的主要区域，因此很多时候也被称为<code>GC堆（Garbage Collected Heap）</code>。从内存回收的角度看，由于现在收集器都是采用分代收集算法，所以Java堆又可以细分为新生代和老年代；再细致一点分为<code>Eden</code>空间、<code>From Survivor</code>空间、 <code>To Survivor</code>空间等。从内分配角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（<code>Thread Local Allocation Buffer， TLAB</code>）。无论如何划分，都与存放内容无关，无论哪个区域，存储的都依旧是对象实例，进一步地划分是为了更好地回收内存，或者更快地分配内存。</p>
<p>根据Java虚拟机规范，堆既可以是物理上连续的也可以是逻辑上连续的，既可以是固定大小的，也可以是可扩展的。不过当前的主流都是可扩展的，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的是与Java堆区分开。</p>
<p>在HotSpot虚拟机中，设计人员将GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。</p>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收的目标主要是针对常量池的回收和对类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>由于常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出<code>OutOfMemoryError</code>异常。</p>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也会被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>在JDK1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，它可以使用native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样在一些情况下可以提高性能，因为避免了在Java堆和native堆中来回复制数据。这部分区域也会出现<code>OutOfMemoryError</code>异常。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>maven编译sun.security.validator.ValidatorException</title>
    <url>/2020/06/01/maven%E7%BC%96%E8%AF%91sun.security.validator.ValidatorException/</url>
    <content><![CDATA[<h4 id="1-使用maven出现的问题"><a href="#1-使用maven出现的问题" class="headerlink" title="1.使用maven出现的问题"></a>1.使用maven出现的问题</h4><p>使用maven的过程中出现如下错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Could not transfer artifact org.springframework.boot:spring-boot-s</span><br><span class="line">tarter-parent:pom:<span class="number">2.0</span><span class="number">.3</span>.RELEASE from/to nexus-aliyun (http:<span class="comment">//maven</span></span><br><span class="line">.aliyun.com/nexus/content/groups/<span class="keyword">public</span>): sun.security.validator.V</span><br><span class="line">alidatorException: PKIX path building failed: sun.security.provider</span><br><span class="line">.certpath.SunCertPathBuilderException: unable to find valid certifi</span><br><span class="line">cation path to requested target</span><br></pre></td></tr></table></figure>

<p>出现这个问题的原因就是https证书问题，java抓取时忽略掉证书才能访问。也可以通过生成网站的证书，然后再访问。</p>
<h4 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2.解决办法"></a>2.解决办法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.File;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;  </span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;  </span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;  </span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;  </span><br><span class="line"><span class="keyword">import</span> java.security.MessageDigest;  </span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;  </span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLContext;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLException;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocket;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.SSLSocketFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManagerFactory;  </span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallCert</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        String host;  </span><br><span class="line">        <span class="keyword">int</span> port;  </span><br><span class="line">        <span class="keyword">char</span>[] passphrase;  </span><br><span class="line">        <span class="keyword">if</span> ((args.length == <span class="number">1</span>) || (args.length == <span class="number">2</span>)) &#123;  </span><br><span class="line">            String[] c = args[<span class="number">0</span>].split(<span class="string">":"</span>);  </span><br><span class="line">            host = c[<span class="number">0</span>];  </span><br><span class="line">            port = (c.length == <span class="number">1</span>) ? <span class="number">443</span> : Integer.parseInt(c[<span class="number">1</span>]);  </span><br><span class="line">            String p = (args.length == <span class="number">1</span>) ? <span class="string">"changeit"</span> : args[<span class="number">1</span>];  </span><br><span class="line">            passphrase = p.toCharArray();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            System.out  </span><br><span class="line">                    .println(<span class="string">"Usage: java InstallCert &lt;host&gt;[:port] [passphrase]"</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"jssecacerts"</span>);  </span><br><span class="line">        <span class="keyword">if</span> (file.isFile() == <span class="keyword">false</span>) &#123;  </span><br><span class="line">            <span class="keyword">char</span> SEP = File.separatorChar;  </span><br><span class="line">            File dir = <span class="keyword">new</span> File(System.getProperty(<span class="string">"java.home"</span>) + SEP + <span class="string">"lib"</span>  </span><br><span class="line">                    + SEP + <span class="string">"security"</span>);  </span><br><span class="line">            file = <span class="keyword">new</span> File(dir, <span class="string">"jssecacerts"</span>);  </span><br><span class="line">            <span class="keyword">if</span> (file.isFile() == <span class="keyword">false</span>) &#123;  </span><br><span class="line">                file = <span class="keyword">new</span> File(dir, <span class="string">"cacerts"</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(<span class="string">"Loading KeyStore "</span> + file + <span class="string">"..."</span>);  </span><br><span class="line">        InputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line">        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());  </span><br><span class="line">        ks.load(in, passphrase);  </span><br><span class="line">        in.close();  </span><br><span class="line">  </span><br><span class="line">        SSLContext context = SSLContext.getInstance(<span class="string">"TLS"</span>);  </span><br><span class="line">        TrustManagerFactory tmf = TrustManagerFactory  </span><br><span class="line">                .getInstance(TrustManagerFactory.getDefaultAlgorithm());  </span><br><span class="line">        tmf.init(ks);  </span><br><span class="line">        X509TrustManager defaultTrustManager = (X509TrustManager) tmf  </span><br><span class="line">                .getTrustManagers()[<span class="number">0</span>];  </span><br><span class="line">        SavingTrustManager tm = <span class="keyword">new</span> SavingTrustManager(defaultTrustManager);  </span><br><span class="line">        context.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[] &#123; tm &#125;, <span class="keyword">null</span>);  </span><br><span class="line">        SSLSocketFactory factory = context.getSocketFactory();  </span><br><span class="line">  </span><br><span class="line">        System.out  </span><br><span class="line">                .println(<span class="string">"Opening connection to "</span> + host + <span class="string">":"</span> + port + <span class="string">"..."</span>);  </span><br><span class="line">        SSLSocket socket = (SSLSocket) factory.createSocket(host, port);  </span><br><span class="line">        socket.setSoTimeout(<span class="number">10000</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Starting SSL handshake..."</span>);  </span><br><span class="line">            socket.startHandshake();  </span><br><span class="line">            socket.close();  </span><br><span class="line">            System.out.println();  </span><br><span class="line">            System.out.println(<span class="string">"No errors, certificate is already trusted"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (SSLException e) &#123;  </span><br><span class="line">            System.out.println();  </span><br><span class="line">            e.printStackTrace(System.out);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        X509Certificate[] chain = tm.chain;  </span><br><span class="line">        <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"Could not obtain server certificate chain"</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(  </span><br><span class="line">                System.in));  </span><br><span class="line">  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(<span class="string">"Server sent "</span> + chain.length + <span class="string">" certificate(s):"</span>);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        MessageDigest sha1 = MessageDigest.getInstance(<span class="string">"SHA1"</span>);  </span><br><span class="line">        MessageDigest md5 = MessageDigest.getInstance(<span class="string">"MD5"</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chain.length; i++) &#123;  </span><br><span class="line">            X509Certificate cert = chain[i];  </span><br><span class="line">            System.out.println(<span class="string">" "</span> + (i + <span class="number">1</span>) + <span class="string">" Subject "</span>  </span><br><span class="line">                    + cert.getSubjectDN());  </span><br><span class="line">            System.out.println(<span class="string">"   Issuer  "</span> + cert.getIssuerDN());  </span><br><span class="line">            sha1.update(cert.getEncoded());  </span><br><span class="line">            System.out.println(<span class="string">"   sha1    "</span> + toHexString(sha1.digest()));  </span><br><span class="line">            md5.update(cert.getEncoded());  </span><br><span class="line">            System.out.println(<span class="string">"   md5     "</span> + toHexString(md5.digest()));  </span><br><span class="line">            System.out.println();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        System.out  </span><br><span class="line">                .println(<span class="string">"Enter certificate to add to trusted keystore or 'q' to quit: [1]"</span>);  </span><br><span class="line">        String line = reader.readLine().trim();  </span><br><span class="line">        <span class="keyword">int</span> k;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            k = (line.length() == <span class="number">0</span>) ? <span class="number">0</span> : Integer.parseInt(line) - <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"KeyStore not changed"</span>);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        X509Certificate cert = chain[k];  </span><br><span class="line">        String alias = host + <span class="string">"-"</span> + (k + <span class="number">1</span>);  </span><br><span class="line">        ks.setCertificateEntry(alias, cert);  </span><br><span class="line">  </span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"jssecacerts"</span>);  </span><br><span class="line">        ks.store(out, passphrase);  </span><br><span class="line">        out.close();  </span><br><span class="line">  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out.println(cert);  </span><br><span class="line">        System.out.println();  </span><br><span class="line">        System.out  </span><br><span class="line">                .println(<span class="string">"Added certificate to keystore 'jssecacerts' using alias '"</span>  </span><br><span class="line">                        + alias + <span class="string">"'"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] HEXDIGITS = <span class="string">"0123456789abcdef"</span>.toCharArray();  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">toHexString</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;  </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(bytes.length * <span class="number">3</span>);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b : bytes) &#123;  </span><br><span class="line">            b &amp;= <span class="number">0xff</span>;  </span><br><span class="line">            sb.append(HEXDIGITS[b &gt;&gt; <span class="number">4</span>]);  </span><br><span class="line">            sb.append(HEXDIGITS[b &amp; <span class="number">15</span>]);  </span><br><span class="line">            sb.append(<span class="string">' '</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> sb.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingTrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> X509TrustManager tm;  </span><br><span class="line">        <span class="keyword">private</span> X509Certificate[] chain;  </span><br><span class="line">  </span><br><span class="line">        SavingTrustManager(X509TrustManager tm) &#123;  </span><br><span class="line">            <span class="keyword">this</span>.tm = tm;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> CertificateException </span>&#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> CertificateException </span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.chain = chain;  </span><br><span class="line">            tm.checkServerTrusted(chain, authType);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存上面的代码，并编译，在运行的时候使用如下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">java InstallCert maven.aliyun.com</span><br></pre></td></tr></table></figure>

<p>将其中的maven.aliyun.com更改为你要访问的地址。接下来会在你存放刚刚编译的代码下面产生一个名为“jssecacerts”的文件，把这个生成的文件拷贝到你的jdk目录下的jre-&gt;lib-&gt;security下面就可以了。</p>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中序遍历的下一个节点</title>
    <url>/2020/05/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针(如下)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeLinkNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeLinkNode left = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode right = <span class="keyword">null</span>;</span><br><span class="line">    TreeLinkNode next = <span class="keyword">null</span>; <span class="comment">// 指向父结点的指针</span></span><br><span class="line"></span><br><span class="line">    TreeLinkNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>中序遍历是先递归遍历左子树再遍历当前父结点最后递归遍历右子树。</p>
<ul>
<li>如果给定的结点有右子树,那么中序遍历的下一个节点就是右子树最左边的结点(最左叶节点是第一个被遍历的).</li>
<li>如果给定结点右子树为空,那么就向上找左子树包含当前结点的第一个祖先结点.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span>&#123;</span><br><span class="line">        TreeLinkNode rc = pNode.right;</span><br><span class="line">        <span class="keyword">if</span>(rc != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//找到右子树的最左叶节点</span></span><br><span class="line">            <span class="keyword">while</span>(rc.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                rc = rc.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> rc;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//找到左子树包含该节点的第一个祖先节点</span></span><br><span class="line">            <span class="keyword">while</span>(pNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeLinkNode parent = pNode.next;</span><br><span class="line">                <span class="comment">//当前节点位于父节点的左子树,则返回父节点</span></span><br><span class="line">                <span class="keyword">if</span>(parent.left == pNode)&#123;</span><br><span class="line">                    <span class="keyword">return</span> parent;</span><br><span class="line">                &#125;</span><br><span class="line">                pNode = parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程中的基本概念</title>
    <url>/2020/05/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h4><h5 id="1-1-什么是进程"><a href="#1-1-什么是进程" class="headerlink" title="1.1 什么是进程"></a>1.1 什么是进程</h5><p>进程是程序的一次执行过程，进程是运行中的程序即是动态的，它是系统运行程序的基本单位。系统运行一个程序就是一个进程从创建到消亡的过程。</p>
<h5 id="1-2什么是线程"><a href="#1-2什么是线程" class="headerlink" title="1.2什么是线程"></a>1.2什么是线程</h5><p>线程与进程类似，但是线程比进程更小，通常一个进程包含若干个线程，每个进程拥有自己的数据，而线程共享进程中的数据，在Java中线程共享JVM进程中的堆和方法区等资源，但是每个线程有都有自己的<strong>程序计数器</strong>、<strong>本地方法栈</strong>、<strong>虚拟机栈</strong>。与进程相比较，创建线程和在各线程之间切换工作的开销比进程小，因此线程也称为“轻量级”进程。</p>
<h5 id="1-3为什么使用多线程"><a href="#1-3为什么使用多线程" class="headerlink" title="1.3为什么使用多线程"></a>1.3为什么使用多线程</h5><p>使用多线程的目的就是提高资源的利用率，使程序具有更好的性能。</p>
<h5 id="1-4使用多线程中可能出现的问题"><a href="#1-4使用多线程中可能出现的问题" class="headerlink" title="1.4使用多线程中可能出现的问题"></a>1.4使用多线程中可能出现的问题</h5><p> 并发编程的目的就是为了提高程序的性能，但是如果使用不当会造成很多的问题，比如：死锁、内存泄漏、线程不安全等。</p>
<h4 id="2-并行与并发"><a href="#2-并行与并发" class="headerlink" title="2.并行与并发"></a>2.并行与并发</h4><ul>
<li>并行：<strong>某一时刻，多个线程同时执行</strong>。并行只能出现在多核CPU，单核CPU是不能够实现并行的，因为一个时刻只能有一个线程使用CPU</li>
<li>并发：<strong>某一时间段，多个线程都在执行</strong>。CPU实际上是通过在不同线程之间频繁的切换，来实现并发的。由于运行和切换耗费的时间很短，所以给用户的感觉就是同一时刻有多个线程在同时执行。但是实际上某一时刻还是只有一个线程在运行。</li>
</ul>
<h4 id="3-创建线程的方式"><a href="#3-创建线程的方式" class="headerlink" title="3. 创建线程的方式"></a>3. 创建线程的方式</h4><p>创建线程主要有四种方式：</p>
<ul>
<li><strong>继承Thread类</strong>并重写run方法，run方法内就是线程要执行的任务。</li>
<li><strong>实现Runnable接口</strong>，并实现run方法</li>
<li><strong>实现Callable接口</strong>，并实现call方法</li>
<li><strong>使用线程池</strong>来创建和使用线程</li>
</ul>
<p>对于使用前两种方式创建线程，并不能在主线程中直接通过调用run()方法的方式运行线程，因为这是普通方法的调用，并没有开启新的线程，应该使用start()方法告知虚拟机，这个线程创建完成可以被调度。</p>
<h4 id="4-线程的生命周期"><a href="#4-线程的生命周期" class="headerlink" title="4.线程的生命周期"></a>4.线程的生命周期</h4><p>线程的生命周期主要包括创建、就绪、运行、阻塞、终止五个状态。在Java中对线程的生命周期又进行了细分，分别是：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>New</strong></td>
<td>初始状态，线程被创建，但是还没有调用start()方法</td>
</tr>
<tr>
<td><strong>Runnable</strong></td>
<td>运行状态，Java线程将操作系统中的就绪态和运行态笼统的称为“运行中”</td>
</tr>
<tr>
<td><strong>Blocked</strong></td>
<td>阻塞状态，表示线程阻塞于锁</td>
</tr>
<tr>
<td><strong>Waiting</strong></td>
<td>等待状态，表示线程进行等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定的动作（通知或中断）</td>
</tr>
<tr>
<td><strong>Timed_waiting</strong></td>
<td>超时等待状态，该状态不同于Waiting,它是可以在指定时间自行返回的</td>
</tr>
<tr>
<td><strong>Terminated</strong></td>
<td>终止状态，表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<h4 id="5-上下文切换"><a href="#5-上下文切换" class="headerlink" title="5.上下文切换"></a>5.上下文切换</h4><blockquote>
<p>当前任务在执行完CPU时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换到这个任务，可以再加载这个线程的状态。任务从保存到再加载的过程就是一次上下文切换。</p>
</blockquote>
<p>由于一个CPU核心某一时刻只能运行一个线程，而当并发的线程数大于CPU核心个数时，为了使得每个线程都能被执行到，CPU采取时间片轮转的方式来运行线程。如果在指定的时间内线程没有运行完成，那么就需要保存当前的状态直到下次运行并且将CPU让给其他线程使用。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<h4 id="6-死锁"><a href="#6-死锁" class="headerlink" title="6.死锁"></a>6.死锁</h4><h5 id="6-1-什么是死锁"><a href="#6-1-什么是死锁" class="headerlink" title="6.1 什么是死锁"></a>6.1 什么是死锁</h5><p>多个线程同时被阻塞，并且他们中的每一个都在等待对方释放已经占有的资源，但是没有一个提前退出，这种时候就造成了死锁</p>
<h5 id="6-2死锁的必要条件"><a href="#6-2死锁的必要条件" class="headerlink" title="6.2死锁的必要条件"></a>6.2死锁的必要条件</h5><ul>
<li><strong>互斥</strong>：某一时刻只能有一个线程使用资源，无法多个线程共享</li>
<li><strong>请求与保持</strong>：线程已经有了一些资源但是还要申请其他的资源</li>
<li><strong>不可剥夺</strong>：如果一个线程拥有了资源，呢吗这个资源不能被强制剥夺</li>
<li><strong>循环等待</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>上述四个条件必须同时满足时才能形成死锁。</p>
<h5 id="6-3如何避免死锁"><a href="#6-3如何避免死锁" class="headerlink" title="6.3如何避免死锁"></a>6.3如何避免死锁</h5><p>避免死锁只需要破坏四个必要条件之一即可，由于某些资源某一时刻只能有一个线程使用（比如打印机）不能实现共享，因此这个条件不能被破坏。可通过破坏其余三个条件来避免死锁：</p>
<ul>
<li><strong>破坏请求与保持</strong>：一次性申请所有的资源</li>
<li><strong>破坏不可剥夺</strong>：如果一个线程申请的资源不能满足，那么允许剥夺其已占有的资源</li>
<li><strong>破坏循环等待</strong>：为资源进行编号，线程按照资源的顺序依次申请资源。</li>
</ul>
<h5 id="6-4-死锁案例与解决方案"><a href="#6-4-死锁案例与解决方案" class="headerlink" title="6.4 死锁案例与解决方案"></a>6.4 死锁案例与解决方案</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(resource1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resources1"</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waitting get reosurces2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(resource2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resources"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(resource2)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resources1"</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"wating get resources1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(resource1)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resources1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述案例中，一个线程锁住resource1然后在没有释放resources的情况下继续申请resources2，而另外一个线程则正好相反，由于满足死锁的四个必要条件，因此导致了死锁。其中使用<code>Thread.sleep(2000)</code>是为了放大产生死锁的概率.</p>
<p>可以将两个线程中的run方法改成一样的，这样就不会产生死锁了。原因是：线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(resource1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resources1"</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waitting get reosurces2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(resource2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resources2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(resource1)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resources1"</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"wating get resources2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span>(resource2)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resources2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程与并发</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>并发</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组中的查找</title>
    <url>/2020/05/29/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>从二维数组左上角的位置开始(假设值为x),将要查找的数字t和x比较,如果t&gt;x则向当前列的下方查找,否则,向当前行的左侧查找,对于每个新位置都进行上述操作直到找到为止.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length ==<span class="number">0</span> || array[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> row = array.length, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> col = array[<span class="number">0</span>].length, c = col-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt;= row-<span class="number">1</span> &amp;&amp; c&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[r][c] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[r][c] &lt; target)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title>利用反射获取实体字段的值</title>
    <url>/2020/06/16/%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%AE%9E%E4%BD%93%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC/</url>
    <content><![CDATA[<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefelectionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"dbj"</span>, <span class="number">100</span>);</span><br><span class="line">        Field[] fields = person.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)&#123;</span><br><span class="line">            String type = field.getType().getName();</span><br><span class="line">            System.out.println(<span class="string">"类型是："</span> + type);</span><br><span class="line">            <span class="comment">//设置字段为可见的（可不通过getter方法访问）</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取字段的值</span></span><br><span class="line">                Object value = field.get(person);</span><br><span class="line">                System.out.println(<span class="string">"值："</span> + value);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>变态跳台阶</title>
    <url>/2020/05/29/%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>青蛙想跳上n级台阶,可以从n-1级跳上来,也可以从n-2级跳上来…也可以从0级直接跳上来,那么f(n) = f(n-1) + f(n-2) + … + f(1) + 1,(最后的1表示直接跳n级上来),其中的f(x) (1&lt;=x&lt;=n-1)又都是相同的但是规模较小的子问题.</p>
<h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            dp[i] += dp[j];</span><br><span class="line">    <span class="keyword">return</span> dp[target - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h5><p>f(n) = f(n-1) + f(n-2) + … + f(1) + 1</p>
<p>f(n-1) = f(n-2) + f(n-3) + …  +(f1) + 1</p>
<p>两式相减:</p>
<p>f(n) - f(n-1) = f(n-1)即f(n) = 2 * f(n-2)</p>
<p>最终得出:f(1), f(2),…,f(n)是一个等比数列,f(n) = 2^(n-1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, target - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序获取open_id,union_id,phone大致流程</title>
    <url>/2020/06/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96open_id,union_id,phone/</url>
    <content><![CDATA[<h4 id="1-获取open-id-union-id"><a href="#1-获取open-id-union-id" class="headerlink" title="1.获取open_id, union_id"></a>1.获取open_id, union_id</h4><h5 id="小程序："><a href="#小程序：" class="headerlink" title="小程序："></a>小程序：</h5><ol>
<li>wx.login获取code（有时限）</li>
<li>wx.getUserInfo获取userInfo, rawData, encryptedData(带有敏感信息的加密数据)等数据</li>
<li>将code连同加密数据encryptedData发给后台进行解密</li>
</ol>
<h5 id="后台："><a href="#后台：" class="headerlink" title="后台："></a>后台：</h5><ol>
<li>根据code, appid, app_secret向微信服务器发送GET请求，获取open_id, session_key（用于解密，有时限），union_id.</li>
<li>使用session_key对密文encryptedData进行解密</li>
</ol>
<h6 id="疑问？"><a href="#疑问？" class="headerlink" title="疑问？"></a>疑问？</h6><p>既然后台发送GET请求到微信服务器能够获取到open_id, union_id为啥还要使用session_key的方式对encryptedData解密获取open_id, union_id?</p>
<p><a href="https://juejin.im/entry/589944da570c3500624e4554" target="_blank" rel="noopener">https://juejin.im/entry/589944da570c3500624e4554</a></p>
<h4 id="2-获取手机号"><a href="#2-获取手机号" class="headerlink" title="2.获取手机号"></a>2.获取手机号</h4><p>button组件的open-type设置为getPhoneNumber,通过回调函数获取到加密数据，然后后台根据session_key和app_id解密数据。</p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>替换空格</title>
    <url>/2020/05/29/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>将一个字符串中的空格替换成 “%20”。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>遍历字符串,若遇到空格,则在字符串后面追加两个空格</li>
<li>用指针p和q分别指向原字符串的最后一个字符和新字符串的最后一个字符.</li>
<li>如果p所指位置是空格,则p自减,并向对应位置依次填入0 2 %三个字符.</li>
<li>如果p所指位置非空格,则直接将q所指位置填入p所指位置的字符,q自减.</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;= p; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                str.append(<span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> q = str.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&gt;=<span class="number">0</span> &amp;&amp; p &lt;q)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(p--);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">' '</span>)&#123;</span><br><span class="line">                str.setCharAt(q--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(q--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(q--, <span class="string">'%'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.setCharAt(q--, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的重复数字</title>
    <url>/2020/05/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由于所有数字都在0到n-1的范围内,所以可以将值为i的元素放到第i个位置上,即nums[i] = i,如果当前位置i已经有一个值为i的元素就知道i值重复了.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = numbers[i];<span class="comment">//保存重复的数字</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//有重复的数字返回true,否则false</span></span><br><span class="line">                &#125;</span><br><span class="line">                swap(numbers, i, numbers[i]);             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = numbers[i];</span><br><span class="line">        numbers[i] = numbers[j];</span><br><span class="line">        numbers[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>用两个栈来完成一个队列的入队和出队</title>
    <url>/2020/05/29/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E6%9D%A5%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E7%9A%84%E5%85%A5%E9%98%9F%E5%92%8C%E5%87%BA%E9%98%9F/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>队列的特点是先进先出,栈的特点是后进先出,顺序进栈的数出栈后变逆序,再经过一次入栈和出栈就变回了原来的顺序.</p>
<ul>
<li>如果两个栈都空,执行pop操作应抛出异常</li>
<li>如果stack2空,执行pop操作应先将stack1中的内容出栈并压入stack2中</li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果stack1和stack2都空应抛出异常</span></span><br><span class="line">        <span class="keyword">if</span>(!stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库join</title>
    <url>/2020/07/06/%E6%95%B0%E6%8D%AE%E5%BA%93-JOIN/</url>
    <content><![CDATA[<h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a inner join b</span><br><span class="line">on a.col &#x3D; b.col</span><br></pre></td></tr></table></figure>

<p>将表a和表b进行内连接，表a中有但是表b中没有的，则最终结果中不包含该条数据</p>
<h4 id="LEFT-OUTER-JOIN"><a href="#LEFT-OUTER-JOIN" class="headerlink" title="LEFT (OUTER) JOIN"></a>LEFT (OUTER) JOIN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a left join b</span><br><span class="line">on a.col &#x3D; b.col</span><br></pre></td></tr></table></figure>

<p>将a表中的所有行和b表中的数据进行连接，如果a表中的数据b表中没有那么就将连接结果中b表的字段设为null</p>
<h4 id="RIGHT-OUTER-JOIN"><a href="#RIGHT-OUTER-JOIN" class="headerlink" title="RIGHT (OUTER)  JOIN"></a>RIGHT (OUTER)  JOIN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a right join b</span><br><span class="line">on a.col &#x3D; b.col</span><br></pre></td></tr></table></figure>

<p>将b表中的所有行和a表中的数据进行连接，如果b表中的数据a表中没有,那么就将连接结果中a表的字段设为null</p>
<h4 id="FULL-OUTER-JOIN"><a href="#FULL-OUTER-JOIN" class="headerlink" title="FULL (OUTER) JOIN"></a>FULL (OUTER) JOIN</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a full join b</span><br><span class="line">on a.col &#x3D; b.col</span><br></pre></td></tr></table></figure>

<p>连接结果包含a和b两张表中全部的行，如果一张表有数据而另外一张表没有与之匹配的，那么这条记录也在结果中，且没有的数据为null</p>
<h4 id="LEFT-OUTER-JOIN-WHERE-IS-NULL"><a href="#LEFT-OUTER-JOIN-WHERE-IS-NULL" class="headerlink" title="LEFT (OUTER) JOIN WHERE IS NULL"></a>LEFT (OUTER) JOIN WHERE IS NULL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a left join b</span><br><span class="line">on a.col &#x3D; b.col</span><br><span class="line">where b.col is null</span><br></pre></td></tr></table></figure>

<p>b表中没有与之匹配的a表的行与b表连接后的数据</p>
<h4 id="RIGHT-OUTER-JOIN-WHERE-IS-NULL"><a href="#RIGHT-OUTER-JOIN-WHERE-IS-NULL" class="headerlink" title="RIGHT(OUTER) JOIN WHERE IS NULL"></a>RIGHT(OUTER) JOIN WHERE IS NULL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a left join b</span><br><span class="line">on a.col &#x3D; b.col</span><br><span class="line">where a.col is null</span><br></pre></td></tr></table></figure>

<p>a表中没有与之匹配的b表的行与a表连接后的数据</p>
<h4 id="FULL-JOIN-WHERE-IS-NULL"><a href="#FULL-JOIN-WHERE-IS-NULL" class="headerlink" title="FULL JOIN WHERE IS NULL"></a>FULL JOIN WHERE IS NULL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select cols</span><br><span class="line">from a left join b</span><br><span class="line">on a.col &#x3D; b.col</span><br><span class="line">where a.col is null</span><br><span class="line">or b.col is null</span><br></pre></td></tr></table></figure>

<p>LEFT (OUTER) JOIN WHERE IS NULL和FULL JOIN WHERE IS NULL的集合。即b表中没有与之匹配的a的行与b表连接的结果以及a表中没有与之匹配的b的行与a表连接的结果。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>join</tag>
      </tags>
  </entry>
  <entry>
    <title>矩形覆盖</title>
    <url>/2020/05/29/%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
</blockquote>
<p>比如n=3时，2*3的矩形块有3种覆盖方法：</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以将问题分解成更小的子问题,覆盖一个2<em>n的大矩形可以先覆盖一个2*1的区域再覆盖剩余的2\</em>(n-1),或者先覆盖 2*2 的矩形，再覆盖 2*(n-2) 的矩形。覆盖一个2*1的区域有一种方法,覆盖2*2的区域有两种方法,而覆盖2*(n-2) 的矩形是规模较小但是问题相同的子问题.</p>
<p>f(1) = 1</p>
<p>f(2) = 2</p>
<p>f(n) = f(1) + f(n-1)或f(n) = f(2) + f(n-2),(其实也可以写成f(n) = f(a) + f(n-a),其中a&gt;=1但是当a&gt;=3时还是要先求f(1),f(2))</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>, pre2 = <span class="number">2</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            ret = pre1 + pre2;</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙跳台阶</title>
    <url>/2020/05/29/%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h4><p>跳一层有一种跳法,跳二层有两种跳法,跳三层可以由第二层再跳一层到达,也可以由第一层跳两层到达,所以第三层的跳法是第二层的跳法加上第一层的跳法.要想跳到第n层,可以从第n-1层和第n-2层分别再跳1层和2层到达,同理第n-1层和第n-2层又都是相同规模较小的子问题.所以推导公式就是f(n) = f(n-1) + f(n-2);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>, pre2 = <span class="number">2</span>, ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            ret = pre1 + pre2;</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的生命周期</title>
    <url>/2020/07/14/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>线程是运行的程序，线程的生命周期就是从线程创建到线程终止的过程。期间可能经历如下六种状态：</p>
<ul>
<li>NEW  创建</li>
<li>RUNNABLE 可运行</li>
<li>BLOCKED 阻塞，阻塞于锁</li>
<li>WAITING 无限期等待</li>
<li>TIMED_WAITING 限期等待</li>
<li>TERMINATED 终止</li>
</ul>
<h5 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h5><p>使用四种创建线程的方式（继承Thread、实现Runnable、实现callable、使用线程池）创建线程后，线程是处于新建状态。当一个线程处于新建状态时，表明这个线程还没有开始执行。</p>
<h5 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h5><p>当创建完线程并调用start()方法后，线程就处于可运行状态。可运行状态表明线程除了处理器资源外已经获取了运行所需要的全部资源，一旦被处理器调度，就可开始运行。Java中使用了可运行态来笼统地表示操作系统中的就绪和运行两种状态。因此处于可运行态的线程可能正在执行，也可能为被执行。</p>
<h5 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h5><p>当线程获取对象的内部锁（不是JUC包中的锁），而这个锁已经被其他线程占用时，当前线程就会进入到阻塞状态。当其他线程不再占用锁时，当前线程才会从阻塞状态中恢复到可运行状态。</p>
<h5 id="无限期等待"><a href="#无限期等待" class="headerlink" title="无限期等待"></a>无限期等待</h5><p>当前线程等待其他线程做出一些特定的动作（通知或中断），即进入该状态的线程需要其他线程进行唤醒。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有超时参数的Object.wait()</td>
<td>Object.notify()或Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置超时参数的Thread.join()</td>
<td>被调用线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park()</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<p>阻塞和等待的区别就是，阻塞状态的是被动进入的（等待获取对象的内部锁，获取不到就被迫进入阻塞状态），而等待状态是主动进入的（自己调用Object.wait(),或者Thread.join()等方法进入的）。</p>
<h5 id="限期等待"><a href="#限期等待" class="headerlink" title="限期等待"></a>限期等待</h5><p>无需其他线程显示唤醒，当经过指定的事件后线程自动从等待状态中恢复到可运行态。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep()</td>
<td>到达执行的时间</td>
</tr>
<tr>
<td>设置了超时参数的Object.wait(millesc)</td>
<td>到达超时时间/Object.notify()/Object.notifyAll()</td>
</tr>
<tr>
<td>设置了超时参数的Thread.join(millsec)</td>
<td>到达超时时间/被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNaons()</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil()</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h6 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h6><p>当线程调用sleep()方法进行休眠时，并不会释放锁。而线程调用wait()时会进入阻塞状态，并且会释放锁，因为线程调用wait()方法进入到阻塞状态后必须由其他线程唤醒，如果不释放锁，那么其他线程就无法获得，进而无法唤醒阻塞的线程。</p>
<h5 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h5><p>终止线程有两种方式：</p>
<ul>
<li>线程运行完run()正常结束</li>
<li>run()方法内没有处理出现的异常的代码而异常终止</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>thread</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>重建二叉树</title>
    <url>/2020/05/29/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据前序遍历序列,将中序遍历序列划分成两部分,左边是左子树的节点集合,右边是右子树的节点集合.根据左右子树集合的个数得知前序遍历序列中哪些是左子树节点哪些是右子树节点.创建当前节点,并依次递归创建左右子树.</p>
<ul>
<li>用四个数字s1,e1,s2,e2分别表示前序遍历序列和中序遍历序列的子树的起始和结束位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTree(pre, in, <span class="number">0</span>, pre.length-<span class="number">1</span>, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">createTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> s1, <span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2)</span></span>&#123;</span><br><span class="line">        TreeNode parent = <span class="keyword">new</span> TreeNode(pre[s1]);</span><br><span class="line">        <span class="keyword">int</span> pos = s2;</span><br><span class="line">        <span class="comment">//在中序遍历序列中找到节点的位置,并以此划分此节点左右子树</span></span><br><span class="line">        <span class="keyword">while</span>(pos &lt; e2 &amp;&amp; in[pos] != pre[s1])&#123;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2&lt;pos)&#123;</span><br><span class="line">            <span class="comment">//创建左子树并赋值给根节点的左孩子</span></span><br><span class="line">            parent.left = createTree(pre, in, s1+<span class="number">1</span>, s1+(pos-s2), s2, pos-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.left = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos &lt; e2)&#123;</span><br><span class="line">            <span class="comment">//创建右子树并赋值给根节点的右孩子</span></span><br><span class="line">            parent.right = createTree(pre, in, s1+(pos-s2)+<span class="number">1</span>, e1, pos+<span class="number">1</span>, e2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字</title>
    <url>/2020/07/15/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>synchronized是用来解决多线程访问共享资源的同步问题。某一时刻只能有一个线程可以进入到synchronized修饰的方法内部执行。在Java早期版本中，synchronized属于重量级锁、效率低下，因为监视器锁(mointor)是依赖于底层操作系统的mutex lock来实现的，由于Java的线程是映射到操作系统原生线程上的，因此唤醒和挂起一个线程需要操作系统的介入，而操作系统实现线程的切换需要由用户态进入到内核态。这个状态转换时间较长，这也是为什么早期synchronized比较慢的原因。不过jdk6之后，Java官方从JVM层面对锁进行了优化，比如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>synchronized关键字标记一个代码块或方法使之成为一个临界区——一次只能有一个线程进入，并执行临界区的代码。在进入临界区前需要获得锁，如果成功获得那么就成功进入到临界区，否则线程就会被阻塞，直到其他线程离开临界区并释放响相应的锁。</p>
<p>synchronized关键字可以使用在如下两个地方：</p>
<ul>
<li>代码块</li>
<li>方法</li>
</ul>
<h5 id="synchronized-block"><a href="#synchronized-block" class="headerlink" title="synchronized block"></a>synchronized block</h5><p>synchronized可以按照如下的方式使用在代码块上，其中的obj是锁住的对象，当多个线程执行这个方法时都需要获得obj的锁，只有获得到了锁才能执行代码块中的内容，否则线程被阻塞直到获得锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子中的两个线程都需要获得object的锁，获得锁的先执行，另外一个线程被阻塞直到获得锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MathClass mathClass = <span class="keyword">new</span> MathClass();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mathClass, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mathClass, <span class="string">"thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//object最好定义为final类型，防止其他在其他地方被修改</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//和下面是一样的，只不过一个锁的是当前对象，一个锁的是object</span></span><br><span class="line">        <span class="comment">// synchronized(this)&#123;</span></span><br><span class="line">        <span class="comment">//     for (int i = 0; i &lt; 3; i++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.println(Thread.currentThread().getName() + "-&gt;" + i);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是先运行获得锁的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread1-&gt;<span class="number">0</span></span><br><span class="line">thread1-&gt;<span class="number">1</span></span><br><span class="line">thread1-&gt;<span class="number">2</span></span><br><span class="line">thread2-&gt;<span class="number">0</span></span><br><span class="line">thread2-&gt;<span class="number">1</span></span><br><span class="line">thread2-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h6 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h6><p>如果锁住的不是同一个对象，那么线程之间不存在资源竞争的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里创建了两个不同的对象</span></span><br><span class="line">        MathClass mathClass1 = <span class="keyword">new</span> MathClass();</span><br><span class="line">        MathClass mathClass2 = <span class="keyword">new</span> MathClass();</span><br><span class="line">        <span class="comment">//两个线程使用的是不同的MathClass,锁对象object不是同一个，因此线程会并发执行</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mathClass1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mathClass2, <span class="string">"thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果并不是按照顺序执行的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread1-&gt;<span class="number">0</span></span><br><span class="line">thread2-&gt;<span class="number">0</span></span><br><span class="line">thread2-&gt;<span class="number">1</span></span><br><span class="line">thread1-&gt;<span class="number">1</span></span><br><span class="line">thread2-&gt;<span class="number">2</span></span><br><span class="line">thread1-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="synchronized-method"><a href="#synchronized-method" class="headerlink" title="synchronized method"></a>synchronized method</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 methodName()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当synchronized使用在非静态方法上时锁住的是当前对象即this</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MathClass mathClass1 = <span class="keyword">new</span> MathClass();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mathClass1, <span class="string">"thread1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mathClass1, <span class="string">"thread2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程同时竞争mathClass1对象的锁，获得锁的先执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">thread1-&gt;<span class="number">0</span></span><br><span class="line">thread1-&gt;<span class="number">1</span></span><br><span class="line">thread1-&gt;<span class="number">2</span></span><br><span class="line">thread2-&gt;<span class="number">0</span></span><br><span class="line">thread2-&gt;<span class="number">1</span></span><br><span class="line">thread2-&gt;<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h6 id="注：-1"><a href="#注：-1" class="headerlink" title="注："></a>注：</h6><p>同理，如果锁住的不是同一个对象那么两线程之间是不存在竞争关系的。</p>
<h5 id="对象级锁和类级锁"><a href="#对象级锁和类级锁" class="headerlink" title="对象级锁和类级锁"></a>对象级锁和类级锁</h5><p>前面介绍的synchronized都是加载非静态方法和非静态代码块上的，此时获取的是对象级锁，当多个线程同时获取同一个对象锁时，只有获得锁的线程会执行，其他会阻塞。synchronized还可以用在静态方法和静态语句块上，此时获取的就是类级锁，即锁住的是整个类，即使使用的是这个类的不同实例，当执行同步代码块时，仍会存在锁竞争。如果一个线程A调用一个实例对象的非静态方法synchronized方法，而线程B调用这个实例对象所属类的静态synchronized方法是允许的，不会发生互斥现象，因为访问静态synchronized方法占用的锁是当前类的锁，而访问非静态synchronized方法占用的锁是当前对象的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized作用于普通方法上，和synchronized(this)的作用是相同的，都是锁住当前的实例对象。</span></span><br><span class="line"><span class="comment"> * 如果是不同的对象，那么不需要进行同步操作。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * synchronzed作用于静态方法或者synchronized(class)都是锁住了整个类，即使访问不同对象的方法仍然</span></span><br><span class="line"><span class="comment"> * 需要进行同步操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个实例</span></span><br><span class="line">        SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">        SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//执行两个线程</span></span><br><span class="line">        service.execute(()-&gt;e1.fun1());</span><br><span class="line">        service.execute(()-&gt;e2.fun1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁住整个类，即使调用该类不同的对象中的方法仍然需要进行同步操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            System.out.println(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果仍旧是先执行获得锁的线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul>
<li><p>synchronized不能使用在构造方法、属性、局部变量上</p>
</li>
<li><p>synchronized锁住的对象如果是空，那么会抛出NullPointerException</p>
</li>
<li><p>synchronized的锁对象除了可以使用this,类级锁，也可以是自定义的对象，但是该对象最好是final修饰的。</p>
</li>
<li><p>不要使用String文字，因为它们可能在应用程序中的其他地方被引用，并且可能导致死锁。可以使用new String()方式创建的字符串对象。</p>
</li>
<li><p>synchronized是可重入锁，即在同步方法内如果调用了相同锁的其他同步代码，那么线程只需要获得一次锁就可以了，进入相同锁的同步代码中时不用重复获取。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2020/07/17/ThreadLocal/</url>
    <content><![CDATA[<h4 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h4><p>当多个线程都是使用同一个<code>Runnable</code>对象来创建的时候，那么<code>Runnable</code>中定义的局部变量就是共享变量，当一个线程对其进行修改时，也会对其他线程造成影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        FormatDate fd = <span class="keyword">new</span> FormatDate();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(fd);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(fd);</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormatDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread-&gt;"</span> + Thread.currentThread().getName() + <span class="string">", pattern-&gt;"</span> + sdf.toPattern());</span><br><span class="line">        <span class="comment">//改变格式</span></span><br><span class="line">        sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">        System.out.println(<span class="string">"Thread-&gt;"</span> + Thread.currentThread().getName() + <span class="string">", pattern-&gt;"</span> + sdf.toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：Thread-0使用完<code>SimpleDateFormat</code>后将其进行改变，Thread-1使用的是修改后的<code>SimpleDateFormat</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-&gt;Thread-<span class="number">0</span>, pattern-&gt;yyyy-MM-dd</span><br><span class="line">Thread-&gt;Thread-<span class="number">0</span>, pattern-&gt;yy-M-d ah:mm</span><br><span class="line">Thread-&gt;Thread-<span class="number">1</span>, pattern-&gt;yy-M-d ah:mm</span><br><span class="line">Thread-&gt;Thread-<span class="number">1</span>, pattern-&gt;yy-M-d ah:mm</span><br></pre></td></tr></table></figure>

<p>有时候需要避免上述的情况——每个线程都有一个共享变量的拷贝，改变自己持有的变量拷贝不会对其他线程中的变量造成影响。Java中提供了<code>ThreadLocal</code>为各个线程提供各自的实例。</p>
<p>如果创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的副本。可以使用<code>get()</code>和<code>set()</code>来获取和修改变量副本，从而可以避免线程安全问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormatDate</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal</span><br><span class="line">            .withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread-&gt;"</span> + Thread.currentThread().getName() + <span class="string">", pattern-&gt;"</span> + threadLocal.get().toPattern());</span><br><span class="line">        <span class="comment">//当前线程重新设置日期格式</span></span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line">        System.out.println(<span class="string">"Thread-&gt;"</span> + Thread.currentThread().getName() + <span class="string">", pattern-&gt;"</span> + threadLocal.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：Thread-0运行结束后格式改变了，但是并没有影响Thread-1的日期格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread-&gt;Thread-<span class="number">0</span>, pattern-&gt;yyyy-MM-dd</span><br><span class="line">Thread-&gt;Thread-<span class="number">0</span>, pattern-&gt;yy-M-d ah:mm</span><br><span class="line">Thread-&gt;Thread-<span class="number">1</span>, pattern-&gt;yyyy-MM-dd</span><br><span class="line">Thread-&gt;Thread-<span class="number">1</span>, pattern-&gt;yy-M-d ah:mm</span><br></pre></td></tr></table></figure>

<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码。因为<code>ThreadLocal</code>类在Java 8中扩展，使用一个新的方法<code>withInitial()</code>，将<code>Supplier</code>功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="ThreadLocal原理"><a href="#ThreadLocal原理" class="headerlink" title="ThreadLocal原理"></a>ThreadLocal原理</h4><p><code>Thread</code>类的源码中包含了<code>threadLocals</code>, <code>inheritableThreadLocals</code>两个类型为<code>ThreadLocalMap</code>的变量，这两个变量都是用来维护<code>ThreadLocal</code>变量的。默认情况下他们都是null，只有第一次调用<code>get()</code>或<code>set()</code>时才会创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * InheritableThreadLocal values pertaining to this thread. This map is</span></span><br><span class="line"><span class="comment">     * maintained by the InheritableThreadLocal class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>的源码：</p>
<p><code>ThreadLocal</code>的set()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，创建<code>ThreadLocal</code>变量实际上是将这个变量放入到了当前线程的<code>ThreadLocalMap</code>中，<code>ThreadLocal</code>可以看作是对<code>ThreadLocalMap</code>的封装，传递了变量值。<code>Thread.currentThread()</code>获取到了当前的线程 ，进而获取线程中的<code>ThreadLocal</code>。不同线程<code>ThreadLocal</code>不同,即具有不同的拷贝，因此可以互不干扰。</p>
<p><code>ThreadLocalMap</code>是一个以<code>ThreadLocal</code>为key,Object为value的Map，同时<code>ThreadLocalMap</code>也是<code>ThreadLocal</code>的静态内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果程序中创建了多个<code>ThreadLocal</code>那么就可以通过<code>ThreadLocal</code>来获取对应的值。</p>
<h4 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h4><p><code>ThreadLocalMap</code>作为一个Map，其Entry继承自<code>WeakReference</code>,由于弱引用会在下一次GC时被回收（不论内存空间是否足够），对于一个<code>ThreadLocalMap</code>来说key为null而value没被清理但是再也引用不到，如果不做任何处理，就可能造成了内存泄漏。<code>ThreadLocalMap</code>实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2020/07/19/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="进程的基本概念"><a href="#进程的基本概念" class="headerlink" title="进程的基本概念"></a>进程的基本概念</h4><blockquote>
<p>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的基本单位（在引入线程后，进程不再是调度的基本单位，线程才是）</p>
</blockquote>
<p>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并且具有间断性和不可再现性的特征。这些特征是动态的，而传统的程序本身是静态的一组指令的集合，它并不能描述这种动态的特征，为此引入了进程的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。</p>
<p>为了使参与并发执行的程序能够独立的运行，必须为之配置一个专门的数据结构，称为进程控制块（PCB）。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。程序段、数据段和PCB三部分组成了进程映像，其中PCB是进程的唯一标识。所谓创建进程就是创建PCB，撤销进程就是撤销PCB。进程映像是静态的，进程是动态的。</p>
<h5 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h5><ol>
<li>创建：进程正在被创建，创建包括分配PCB（申请失败会创建失败）、为进程分配资源（资源分配失败会导致进程进入到阻塞态并不是创建失败）</li>
<li>就绪态：进程创建完成，一旦被处理机调度即可调度，即只缺少处理及资源</li>
<li>运行态：正在被处理机执行</li>
<li>阻塞态：进程因某事件而被阻塞，如等待资源为可用或等待I/O完成。即使处理机空闲该进程也无法运行。注意和就绪态的区别</li>
<li>终止态：进程正常结束或者出现了异常导致结束。</li>
</ol>
<h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><p>进程通信是指进程之间的信息交换。PV操作时低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。</p>
<p><strong>1.共享存储</strong></p>
<p>通信进程之间存在一块共享的内存，通过对这块区域进行读写操作完成进程之间的信息交换。在对共享空间进行读写操作时，需要使用同步互斥工具。</p>
<p><strong>2.消息传递</strong></p>
<p>进程间的数据交换是以格式化的消息为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送和接收消息两个原语进行数据交换。</p>
<p>a. 直接通信方式：发送进程直接把消息发送给接收进程，并将其挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。</p>
<p>b. 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中获取消息。这种中间实体称为信箱，这种通信方式又称为信箱通信。</p>
<p><strong>3.管道通信</strong></p>
<p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件（Linux中大小为4KB）。向管道（共享文件）提供输入的发送进程，以字符流方式将大量的数据写入到管道，而接收管道输出的接收进程，则从管道中接收数据。为了协调双方的通信，管道机制必须提供以下三方面协调能力：互斥、同步和确定对方存在。管道通信是半双工通信，如果想实现全双工需要使用两个管道文件。</p>
<h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>引入进程的目的是为了是多道程序并发执行，以提高资源利用率和系统的吞吐量，增加并发程度；而引入线程则是为了减小程序在并发执行时付出的时空开销，提高系统的并发性能。</p>
<p>线程也称为“轻量级线程”，它是一个基本的CPU执行单元，由线程ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程除了拥有一些运行时必不可少的资源外不拥有其他资源，进程才是资源分配的基本单位。进程中的线程共享进程中的资源。</p>
<h4 id="进程与线程的比较"><a href="#进程与线程的比较" class="headerlink" title="进程与线程的比较"></a>进程与线程的比较</h4><ol>
<li><p>调度：在传统操作系统种线程是资源分配和调度的基本单位，引入线程后线程是调度的基本单位，而进程依旧是资源的分配单位。在同一个进程中，线程的切换不会引起进程切换。</p>
</li>
<li><p>拥有资源：不论是否引入了线程，进程都是资源的分配单位，线程除了必不可少的资源外并不拥有其他资源，进程中的线程共享进程的资源。如果线程也拥有资源，那么切换线程和切换进程的开销一样大，也就没有必要引入线程了。</p>
</li>
<li><p>并发性：引入线程后，不仅进程之间可以并发执行，线程之间也可以并发执行，从而提高了系统的并发性。</p>
</li>
<li><p>系统开销：由于创建和撤销进程系统需要为之分配和回收资源，因此操作系统所付出的开销远大于创建或撤销线程时的开销。</p>
</li>
<li><p>地址空间和其他资源：线程的地址空间相互之间独立，同一进程中的线程共享进程的资源，某进程中的线程对其他线程是不可见的。</p>
</li>
<li><p>通信：进程通信（IPC）需要进程同步或互斥手段的辅助，以保证数据的一致性，而线程间可以直接读/写进程数据段（如全局变量）来进行通信。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口的最大值</title>
    <url>/2020/07/21/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用极大堆来保存当前窗口的元素，堆顶就是窗口的最大值。滑动窗口时将窗口最左边的元素从堆中去除，并将新元素加入到堆中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span> [] num, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num.length == <span class="number">0</span> || size &gt; num.length || size &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//极大堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; w = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1,o2)-&gt;o2-o1);</span><br><span class="line">    <span class="comment">//设置初始的极大堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        w.add(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆顶为最大值</span></span><br><span class="line">    ret.add(w.peek());</span><br><span class="line">    <span class="comment">//滑动窗口，找出每个窗口的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = i+size; j &lt; num.length; i++,j++)&#123;</span><br><span class="line">        <span class="comment">//将最左边元素移除</span></span><br><span class="line">        w.remove(num[i]);</span><br><span class="line">        <span class="comment">//将新元素加入堆中</span></span><br><span class="line">        w.add(num[j]);</span><br><span class="line">        <span class="comment">//堆顶为最大值</span></span><br><span class="line">        ret.add(w.peek());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>最长不含重复字符的子字符串</title>
    <url>/2020/07/21/%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h5><p>使用一个数组d[], d[i]（初始值为1）表示以第i位为尾的子串的最长不包含重复字符的子字符串的长度。依次遍历字符串，对于字符串的第i位s[i],和当前字符之前的d[i-1]位逐个比较（从i-1到i-d[i-1]位），如果两者不同，d[i]自增，否则结束当前比较。</p>
<p>为什么要和自己的前d[i-1]位进行比较？</p>
<p>因为d[i-1]是s[i-1]的最长无重复字符的子串长度，当将s[i]加入后，s[i]可能与求得的子串中的字符重复，比较的目的就是找出加上s[i]后的最长无重复字符的子串长度</p>
<p>在循环的过程中使用max来记录最长的无重复字符的子串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max = d[<span class="number">0</span>];<span class="comment">//记录最长的不包含重复字符的子串长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        d[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= d[i-<span class="number">1</span>]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - j) != c)&#123;</span><br><span class="line">                d[i]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>使用滑动窗口的方法来保存最长无重复字符的子串（窗口内的字符是当前不包含重复字符的最长子串）。滑动窗口使用HashMap来进行存储，其中key是字符，value是对应的下标。使用head和tail表示滑动窗口的右边界和左边界（窗口的范围是[tail,head]）。每遍历一个字符就在HashMap查找对应的下标pos，如果下标不为空说明当前字符在HashMap中，那么就将窗口的左边界移动到pos的下一位（需要取pos和tail的最大值，因为pos对应的下标可能并不在当前滑动窗口内（已经滑过去了））,无论HashMap中是否存在当前字符，都需要将该字符加入到hashMap中（如果存在表示的是更新字符的下标），最后返回滑动窗口的最大值即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>, max = <span class="number">1</span>;</span><br><span class="line">    map.put(s.charAt(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        head = i;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="comment">//获取当前字符的下标</span></span><br><span class="line">        Integer pos = map.get(c);</span><br><span class="line">        <span class="comment">//如果在map中，则更新tail</span></span><br><span class="line">        <span class="keyword">if</span>(pos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            tail = Math.max(pos+<span class="number">1</span>, tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新或保存当前字符及其下标</span></span><br><span class="line">        map.put(c, i);</span><br><span class="line">        <span class="comment">//修改滑动窗口最大值</span></span><br><span class="line">        max = Math.max(max, head-tail+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的最近公共祖先</title>
    <url>/2020/07/22/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt=""></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>由于针对的是二叉搜索树，因此查找公共祖先节点时可以利用二叉搜索树的性质：节点右子树的值都比节点值大，节点左子树的值都比节点值小。</p>
<p>对于给定两个节点p,q可以和当前节点进行比较，如果都小于当前节点，说明p和q位于节点的左子树，其最近的公共祖先节点也在左子树中；当p和q都大于当前节点值，说明p和q位于节点的右子树，其最近的公共祖先节点也在右子树中。其余情况说明p，q分别位于当前节点的左右子树中，那么最近公共祖先节点就是当前根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.val &lt; root.val &amp;&amp; q.val &lt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中两个节点的最低公共祖先</title>
    <url>/2020/07/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
</blockquote>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt=""></p>
<p>示例 1:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">1</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">1</span> 的最近公共祖先是节点 <span class="number">3</span>。</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">7</span>,<span class="number">4</span>], p = <span class="number">5</span>, q = <span class="number">4</span></span><br><span class="line">输出: <span class="number">5</span></span><br><span class="line">解释: 节点 <span class="number">5</span> 和节点 <span class="number">4</span> 的最近公共祖先是节点 <span class="number">5</span>。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">所有节点的值都是唯一的。</span><br><span class="line">p、<span class="selector-tag">q</span> 为不同节点且均存在于给定的二叉树中。</span><br></pre></td></tr></table></figure>

<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先后在左右子树中查找p和q两节点，如果p和q分别在两个子树中，那么父节点就是当前根节点。如果左子树空右子树不空说明p、q位于左子树中,如果左子树空右子树不空说明p、q位于右子树中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前根节点是否是p或者q</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == root || q == root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在左子树中查找p或者q</span></span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    <span class="comment">//在右子树中查找p或者q</span></span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="comment">//如果left为空说明p,q位于右子树，如果right为空说明p,q位于左子树，如果left、right都不为空说明p,q位于左右子树中，则公共父节点就是根节点</span></span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘机数组</title>
    <url>/2020/07/25/%E6%9E%84%E5%BB%BA%E4%B9%98%E6%9C%BA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * … * A[n-1]，B[n-1] = A[0] * A[1] * … * A[n-2];）</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果题目不限制不能使用除法这一约束，那么可以求出数组的乘积，然后除以当前位置的数就得到结果了（注意除数可能为零的情况）。下面介绍一种O(n)的解题思路：</p>
<blockquote>
<p>根据题意：B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]</p>
<p>用A[i]将A数组分成前后两部分记 C[i] = A[0]A[1]…A[i-1] 和 D[i] = A[i+1]A[i+2]…A[n-1]</p>
<p>易知C[i] = C[i-1] * A[i-1] ,而D[i] = D[i+1] * A[i+1]</p>
<p>这样就可以避免重复计算，由前项或者后项就可以推出当前项</p>
<p>最后B[i] = C[i] * D[i]</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = A.length;</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求出上述的C[i]（没必要创建一个新数组，使用B数组即可。B[0] = 1,然后后一项依据前一项得出）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求出上述的D[i](倒序求)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- )&#123;</span><br><span class="line">        temp *= A[i+<span class="number">1</span>];</span><br><span class="line">        B[i] *= temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中重复的数字</title>
    <url>/2020/07/28/%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote>
<p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p>
<p>由于数组中的值在[0, n-1]之间，所以可以将数组中i位置的元素j放入到数组的j位置上，如果j位置上已经是j了，那么就说明该元素重复，返回这个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="comment">//循环将元素放入到对应的位置</span></span><br><span class="line">        <span class="keyword">while</span>(i != numbers[i])&#123;</span><br><span class="line">            <span class="comment">//判断numbers[i]位置上的元素是否已经有了相同元素（出现重复）</span></span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将当前元素放到正确的位置上</span></span><br><span class="line">            swap(numbers, i, numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">    numbers[i] = numbers[j];</span><br><span class="line">    numbers[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在没有限制不可使用额外空间的条件下，可以使用标记数组来解决。对于数组中的每一个元素i判断标记数组中对应的i位置位置是否被标记为true,如果是表明元素重复，返回该元素，否则将元素标记为true.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] a = <span class="keyword">new</span> <span class="keyword">boolean</span>[length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[numbers[i]] == <span class="keyword">true</span>)&#123;</span><br><span class="line">            duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">            ret = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            a[numbers[i]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>LeetCode</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC数据绑定流程</title>
    <url>/2020/07/28/SpringMVC%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>SpringMVC主框架将ServletRequest对象及目标方法的入参实例传递给WebDataBindFactory实例，以创建DataBinder实例对象</p>
<p>DataBinder调用装配在SpringMVC上下文中的ConversionService组件进行数据类型转换、数据格式化工作。将Servlet中请求信息填充到入参对象中</p>
<p>调用Validator组件对已经绑定请求消息的入参对象进行数据合法性校验，并最终生活数据绑定结果BindingData对象</p>
<p>SpringMVC抽取BindingResult中的入参对象和校验错误对象，将他们赋给处理方法的响应入参</p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>@RequestParam和@RequestBody</title>
    <url>/2020/07/28/@RequestParam%E5%92%8C@RequestBody/</url>
    <content><![CDATA[<h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p>@RequestParam用于将方法的参数和Request对象参数进行绑定。Spring的API文档这样写道：<code>In Spring MVC, &quot;request parameters&quot; map to query parameters, form data, and parts in multipart requests. This is because the Servlet API combines query parameters and form data into a single map called &quot;parameters&quot;, and that includes automatic parsing of the request body.</code>即在SpringMVC中请求参数主要映射查询参数、表单数据、多部分请求中的部分（？？？）。这是因为Servlet API将查询参数、表单数据封装成了一个叫做parameters的map,并且该映射包括请求体的自动解析。</p>
<p>如果方法参数是Map并且指明了参数的名称，那么就会将这些参数放入到map中，如果没有指定参数名，那么将会把所有的参数全部映射到map中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">全部映射  http://localhost:8080/user/getMap1?id=1&amp;name=dbj&amp;password=12345</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getMap1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMap1</span><span class="params">(@RequestParam Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : map.entrySet())&#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"-&gt;"</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">映射指定的参数 http://localhost:8080/user/getMap2?id=1&amp;name=dbj&amp;password=12345</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getMap2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMap2</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span>Integer id, @<span class="title">RequestParam</span><span class="params">(<span class="string">"name"</span>)</span>String name)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"id:"</span> + id + <span class="string">"-&gt;name:"</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ReuqestParam不仅能够用于处理GET请求，还能够处理POST。@RequestParam能够将方法的参数和请求体进行映射，但是这里有一个要求，content-type=application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式），否则就会转换异常。</p>
<p><img src="https://gitee.com/daibingjie/picture_bed/raw/master/image-20200728104911714.png" alt="image-20200728104911714"></p>
<h4 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h4><p>@RequestBody用于将请求体中的参数映射为方法的参数中，并且还能处理content-type是application/x-www-form-urlencoded之外的情况，比如：application/json, application/xml等；</p>
<p>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用。</p>
<p>传递的参数是json格式的字符串，在postman中的body中选择raw -&gt; JSON(application/json)</p>
<p><img src="https://gitee.com/daibingjie/picture_bed/raw/master/image-20200728170043865.png" alt="image-20200728170043865"></p>
<p>处理方法的参数使用POJO来与json字符串进行映射，（POJO和传来的json数据的字段相一致才能为POJO字段赋值）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h4><p>@RequestHeader是用于将方法的参数和请求头中的参数进行映射的，如果请求的参数是Map,那么在不指定映射的参数那么会将请求头中所有的参数全部封装到map中。</p>
<p>指定了获取请求头中的参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将传递的参数放入到请求头中</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getHeader"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInHeader</span><span class="params">(@RequestHeader(<span class="string">"id"</span>)</span>Integer id )</span>&#123;</span><br><span class="line">    User userById = userService.getUserById(id);</span><br><span class="line">    System.out.println(userById);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没指定参数的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/getHeader1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserInHeader</span><span class="params">(@RequestHeader Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">    map.forEach((k,v)-&gt;System.out.println(k + <span class="string">"="</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">host&#x3D;localhost:8080</span><br><span class="line">connection&#x3D;keep-alive</span><br><span class="line">cache-control&#x3D;no-cache</span><br><span class="line">name&#x3D;dbj</span><br><span class="line">password&#x3D;123</span><br><span class="line">user-agent&#x3D;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.89 Safari&#x2F;537.36</span><br><span class="line">id&#x3D;1</span><br><span class="line">postman-token&#x3D;bd7258b8-68dc-02f3-ace9-17e9e0de04b9</span><br><span class="line">accept&#x3D;*&#x2F;*</span><br><span class="line">sec-fetch-site&#x3D;none</span><br><span class="line">sec-fetch-mode&#x3D;cors</span><br><span class="line">sec-fetch-dest&#x3D;empty</span><br><span class="line">accept-encoding&#x3D;gzip, deflate, br</span><br><span class="line">accept-language&#x3D;zh-CN,zh;q&#x3D;0.9,zh-TW;q&#x3D;0.8,en-US;q&#x3D;0.7,en;q&#x3D;0.6</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>TCP连接的建立与释放</title>
    <url>/2020/07/29/TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<h4 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a><strong>TCP连接的建立</strong></h4><h5 id="为什么要进行三次握手"><a href="#为什么要进行三次握手" class="headerlink" title="为什么要进行三次握手"></a><strong>为什么要进行三次握手</strong></h5><blockquote>
<p> 三次握手的目的就是为了建立可靠的通信信道，保证数据能够正常发送给对方，自己能够正常接收对对方发送的数据。</p>
</blockquote>
<p>三次握手的流程图如下所示：</p>
<p><img src="https://gitee.com/daibingjie/picture_bed/raw/master/image-20200729174410004.png" alt="image-20200729174410004"></p>
<p>一开始，服务器B处于监听状态(LISTEN)，监听来自客户端A的请求信息。</p>
<ol>
<li>A在打算建立TCP连接时向B发送连接请求报文，这时报文中的同步为SYN = 1，同时消耗一个序号seq = x(TCP规定，SYN报文段不能携带数据，但是需要消耗一个序号。)这时A处于SYN-SENT(同步已发送)状态</li>
<li>服务器B在接收到连接请求报文后，如果同意建立连接，则向A发送确认。在确认报文中将SYN和ACK置为1，确认号为x+1，同时该报文也消耗一个序号seq = y。这时B进入到SYN-RCVD(同步收到)状态。(也可以将这个报文段分成两个报文，一个是确认报文(ACK = 1, ack = x + 1)，一个是同步报文(SYN = 1, seq = y))</li>
<li>客户端A在收到服务器B的确认报文后，还要向B发送确认报文，其中ACK = 1，seq = x+1, 确认号ack = y + 1;这时TCP的连接已经建立，A进入ESTABLISHED状态。当B收到A的确认报文后也进入到ESTABLISHED状态，此时双方可以进行数据传输。</li>
</ol>
<h5 id="为什么客户端最后还要发送一次确认？"><a href="#为什么客户端最后还要发送一次确认？" class="headerlink" title="为什么客户端最后还要发送一次确认？"></a><strong>为什么客户端最后还要发送一次确认？</strong></h5><p>这是为了防止已经失效的连接请求报文段突然又传送到服务器B，使服务器B误以为客户端A又想建立一次连接。</p>
<h6 id="已失效的连接请求报文段"><a href="#已失效的连接请求报文段" class="headerlink" title="已失效的连接请求报文段"></a><strong>已失效的连接请求报文段</strong></h6><p>A发送了一个请求连接报文，但是这个报文在传输的过程中并没有按时到达（迟到了），直到连接释放的某个时刻才到达B。B收到这个本应失效的请求报文，以为A想再次建立连接。于是就向A发送确认报文，同意建立连接。假定不采用三报文握手，那么只要B发送确认，新连接就建立了。</p>
<p>由于A并没有要求建立连接，因此对于B发送的确认并不理会，也不会向B发送数据。但是B以为新的传输连接已经建立，并且一直等待A发送数据。B的许多资源就这样浪费了。而在使用三次握手的方法时，由于A不会对报文进行确认，因此B收不到A发送来的确认，就知道A没有要求建立连接。</p>
<h4 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a><strong>TCP连接的释放</strong></h4><p>TCP连接释放需要进行四次报文握手（即<strong>四次挥手</strong>），</p>
<h5 id="为什么要进行四次挥手"><a href="#为什么要进行四次挥手" class="headerlink" title="为什么要进行四次挥手"></a><strong>为什么要进行四次挥手</strong></h5><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。  </p>
<p>TCP连接释放的流程如下所示：</p>
<p><img src="https://gitee.com/daibingjie/picture_bed/raw/master/image-20200729174448119.png" alt="image-20200729174448119"></p>
<ol>
<li>客户端A的应用进程先向其TCP发出释放连接报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部的终止控制位FIN置1，其序号seq = u(u等于前面数据传输的最后一个字节的序号+1)，此时A处于FIN-WAIT-1状态，等待B的确认。</li>
<li>服务器B收到A发送的连接释放报文后，对该报文进行确认，置ACK = 1，序号seq = v(数据传输阶段，B发送的最后一个子接的序号+1),确认号ack = u + 1,发送完后B处于CLOSE-WAIT状态。TCP服务器进程这时应通知高层应用进程，因而A到B这个方向的连接就断开了，这时TCP处于半关闭状态，虽然A没有数据要发送，但是B可能仍有数据要传送，此时A仍要接收数据(B到A这个方向的连接还没有关闭)，A收到B的确认后进入到FIN-WAIT-2状态。</li>
<li>B发送完数据后，向客户端A发送连接释放报文，置FIN = 1，序号seq = w(w是TCP半关闭状态期间，B发送数据的最后一个字节序号+1)。除此之外B还必须重复上次已发送过的确认号ack = u + 1.这时B就进入到LAST-ACK状态，等待A的确认。</li>
<li>A在收到B的连接释放报文段后，必须对此报文进行确认，确认报文的ACK = 1, ack = w + 1,序号seq = u + 1。 发送确认报文后需要启动时长为2MSL(MSL叫做最长报文段寿命，RFC文档建议MSL = 2min)的等待计时器，B接收到确认报文后便处于COLSED状态，2MSL后A就处于CLOSED状态。</li>
</ol>
<h5 id="为什么客户端必须等待2MSL的时间？"><a href="#为什么客户端必须等待2MSL的时间？" class="headerlink" title="为什么客户端必须等待2MSL的时间？"></a><strong>为什么客户端必须等待2MSL的时间？</strong></h5><ol>
<li>为了保证确认报文段能够到达服务器B。这个确认报文很可能会丢失，因而使处于LAST-ACK的B收不到A发送的对FIN + ACK的确认报文。之后B会重传这个FIN + ACK报文，而A能够在2MSL时间内收到重传的FIN + ACK报文，接着对报文进行确认，并且将等待计时器重置为2MSL。最后，A和B都进入到CLOSED状态。如果A不等待2MSL而是直接关闭连接，那么如果对FIN + ACK的确认丢失，A将无法收到B重传的FIN + ACK报文 ，而B由于收不到A发送的确认，无法正常进入到CLOSED状态。</li>
<li>防止”已失效的连接请求报文段”出现在本连接中。A在发送完最后一个确认后，再经过2MSL，就可以是本连接中所有的报文段都从网络中消失。这样就会使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h5 id="如果客户端的主机突然出现故障怎么办？"><a href="#如果客户端的主机突然出现故障怎么办？" class="headerlink" title="如果客户端的主机突然出现故障怎么办？"></a><strong>如果客户端的主机突然出现故障怎么办？</strong></h5><p>TCP还设置了一个保活计时器(keepalive timer)。服务器每收到一个客户端发送来的数据就将计时器重置，时间的设置通常是两个小时。若两个小时都没有收到来自客户端的数据，服务器就会发送探测报文，一后每隔75秒就发送一次，如果连续10次都没有客户端的响应，服务器就认为客户端出现了故障，接着就关闭这个连接。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>深克隆和浅克隆</title>
    <url>/2020/08/10/%E6%B7%B1%E5%85%8B%E9%9A%86%E5%92%8C%E6%B5%85%E5%85%8B%E9%9A%86/</url>
    <content><![CDATA[<h4 id="什么是Java-clone"><a href="#什么是Java-clone" class="headerlink" title="什么是Java clone"></a>什么是Java clone</h4><p>clone就是复制源对象的一个副本对象，默认情况下Java复制是逐个字段进行复制的，这是因为Object这个类对具体的类对象的结构一无所知。当JVM执行克隆时会进行如此下的操作：</p>
<ol>
<li>如果被拷贝对象中包含基本数据类型，那么基本数据类型会被完全复制一份。</li>
<li>如果被拷贝对象中包含引用类型的对象，那么默认情况下仅仅对引用进行简单的复制，实际上两个引用指向相同的内存地址。</li>
</ol>
<p>由于包含引用类型的对象的拷贝与源对象共享子对象，所以，任何一方改变子对象，都会对其他对象造成影响。如果引用类型是不可变的，那么就不会造成影响，比如String类型。</p>
<h4 id="Cloneable接口"><a href="#Cloneable接口" class="headerlink" title="Cloneable接口"></a>Cloneable接口</h4><p>要想实现自定义的克隆操作，就需要实现Cloneable接口，并重写clone()方法(<strong>clone()方法并不是Cloneable接口中的方法，而是Object中的protected方法</strong>)，此处的Cloneable是标识接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Employee)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h4><p>浅克隆就是仅仅克隆基本数据类型，对于应用类型引用的是源对象中的引用对象，即在浅克隆中，克隆前后的引用类型指向相同的内存地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Department dept;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, Department dept)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Employee)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Department</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportException</span>&#123;</span><br><span class="line">        Department dept = <span class="keyword">new</span> Department(<span class="number">1</span>, <span class="string">"Software Develop"</span>);</span><br><span class="line">        Employee emp = <span class="keyword">new</span> Employee(<span class="number">11</span>, <span class="string">"asd"</span>, dept);</span><br><span class="line">        Employee copy = emp.clone();</span><br><span class="line">        System.out.println(emp == copy);<span class="comment">//false</span></span><br><span class="line">        copy.setName(<span class="string">"qwe"</span>);</span><br><span class="line">        System.out.println(emp.getName + <span class="string">"-&gt;"</span> + copy.getName());<span class="comment">//asd-&gt;qwe</span></span><br><span class="line">        System.out.println(emp.dept == copy.dept);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h4><p>深克隆会对类中的其他引用类型也进行拷贝，而不仅仅是进行简单的引用复制（指向相同的对象）。具体实现和浅克隆相差不大，实现Cloneable接口，重写Clone()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportException</span>&#123;</span><br><span class="line">        Employee clone = (Employee)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//克隆可变的引用类型对象，Department也应该实现Cloneable接口并实现clone()方法</span></span><br><span class="line">        Department dept = (Department)<span class="keyword">super</span>.clone();</span><br><span class="line">        clone.department = dept;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深拷贝时，类中的引用类型也必须要实现Cloneable接口并重写clone()方法，只要clone方法中含有没有实现Cloneable接口的对象，Object类中的clone()方法就会抛出一个CloneNotSupportException异常。</p>
<p>除了使用上述方式进行深克隆外，还可以使用序列化的方式来对对象进行深克隆,但是并不建议这样做，因为序列化开销很大，并且并不是所有的类都实现了Serializable接口（也是标识接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Employee <span class="title">clone</span><span class="params">(Employee obj)</span></span>&#123;</span><br><span class="line">    Employee cloneObj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//写入字节流</span></span><br><span class="line">        ByteArrayOutputStream out = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream obs = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">        obs.writeObject(obj);</span><br><span class="line">        obs.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分配内存，写入原始对象，生成新对象</span></span><br><span class="line">        ByteArrayInputStream ios = <span class="keyword">new</span> ByteArrayInputStream(out.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(ios);</span><br><span class="line">        <span class="comment">//返回生成的新对象</span></span><br><span class="line">        cloneObj = (Employee) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
